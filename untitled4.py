# -*- coding: utf-8 -*-
"""Untitled4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OuOZWbOeFsy9nAoBbn37tg2Zo5WYRce8
"""

# prompt: import pandas

import pandas as pd

# prompt: import file /content/Murikipudi Prudhvi Ganesh Murikipudi Prudhvi Ganesh - revolutioncart_data.csv

import pandas as pd
df = pd.read_csv('/content/Murikipudi Prudhvi Ganesh Murikipudi Prudhvi Ganesh - revolutioncart_data.csv')

# prompt: df

df

# prompt: convert all categorical data into numerical data

from sklearn.preprocessing import LabelEncoder

# Create a LabelEncoder object
le = LabelEncoder()

# Iterate through each column in the DataFrame
for column in df.columns:
  # Check if the column data type is object (categorical)
  if df[column].dtype == 'object':
    # Fit and transform the column using LabelEncoder
    df[column] = le.fit_transform(df[column])

# Print the updated DataFrame
print(df)

# prompt: consider monthly_revenue as x and others as y

X = df['monthly_revenue']
y = df.drop('monthly_revenue', axis=1)

print("X (monthly_revenue):")
print(X)
print("\ny (other columns):")
print(y)

# prompt: split the data x and y into train and test data

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

print("X_train shape:", X_train.shape)
print("X_test shape:", X_test.shape)
print("y_train shape:", y_train.shape)
print("y_test shape:", y_test.shape)

# prompt: create a regression model for X_train, y_train

from sklearn.linear_model import LinearRegression

# Create a Linear Regression model
model = LinearRegression()

# Reshape X_train to be a 2D array as required by scikit-learn
X_train_reshaped = X_train.values.reshape(-1, 1)

# Fit the model to the training data
model.fit(X_train_reshaped, y_train)

# You can now use the trained model to make predictions on the test data (X_test)
# y_pred = model.predict(X_test.values.reshape(-1, 1))

# prompt: give me accuracy of the model

from sklearn.metrics import mean_squared_error, r2_score

# Reshape X_test to be a 2D array
X_test_reshaped = X_test.values.reshape(-1, 1)

# Make predictions on the test data
y_pred = model.predict(X_test_reshaped)

# Calculate the R-squared score
r2 = r2_score(y_test, y_pred)

# Calculate the mean squared error
mse = mean_squared_error(y_test, y_pred)


print("R-squared:", r2)
print("Mean Squared Error:", mse)

# prompt: create a logistic regression model for X_train and y_train

from sklearn.linear_model import LogisticRegression

# Create a Logistic Regression model
logistic_model = LogisticRegression(max_iter=1000)  # Increase max_iter if needed

# Reshape X_train to be a 2D array as required by scikit-learn
X_train_reshaped = X_train.values.reshape(-1, 1)

# Fit the model to the training data
logistic_model.fit(X_train_reshaped, y_train)

# You can now use the trained model to make predictions on the test data (X_test)
# y_pred_logistic = logistic_model.predict(X_test.values.reshape(-1, 1))

# prompt: create a knn regressor model

from sklearn.neighbors import KNeighborsRegressor

# Create a KNN Regressor model
knn_model = KNeighborsRegressor(n_neighbors=5)  # You can adjust the number of neighbors

# Reshape X_train to be a 2D array as required by scikit-learn
X_train_reshaped = X_train.values.reshape(-1, 1)

# Fit the model to the training data
knn_model.fit(X_train_reshaped, y_train)

# Make predictions on the test data
y_pred_knn = knn_model.predict(X_test_reshaped)

# Evaluate the model
r2_knn = r2_score(y_test, y_pred_knn)
mse_knn = mean_squared_error(y_test, y_pred_knn)

print("KNN Regressor:")
print("R-squared:", r2_knn)
print("Mean Squared Error:", mse_knn)

# prompt: give me the accuracy of knn regressor model in percentage

from sklearn.metrics import accuracy_score

# Assuming y_test and y_pred_knn are your true and predicted values for the KNN model
# Convert predicted values to binary (0 or 1) if your target variable is binary
# y_pred_knn_binary = [1 if pred > 0.5 else 0 for pred in y_pred_knn]

# Calculate accuracy
# accuracy_knn = accuracy_score(y_test, y_pred_knn_binary) * 100

# Print the accuracy
# print("KNN Regressor Accuracy:", accuracy_knn, "%")


# You can't directly calculate accuracy for regression problems as you would for classification
# because regression predicts continuous values.

# However, you can calculate the R-squared score, which is a measure of how well the model
# fits the data, and can be used as a proxy for accuracy.

# Calculate the accuracy using R-squared
accuracy_knn = r2_knn * 100  # Multiply by 100 to get a percentage

# Print the accuracy
print("KNN Regressor Accuracy:", accuracy_knn, "%")

# prompt: create a model on random forest regressor of X_train and y_train

from sklearn.ensemble import RandomForestRegressor

# Create a Random Forest Regressor model
rf_model = RandomForestRegressor(n_estimators=100, random_state=42)  # You can adjust n_estimators

# Reshape X_train to be a 2D array as required by scikit-learn
X_train_reshaped = X_train.values.reshape(-1, 1)

# Fit the model to the training data
rf_model.fit(X_train_reshaped, y_train)

# Make predictions on the test data
y_pred_rf = rf_model.predict(X_test_reshaped)

# Evaluate the model
r2_rf = r2_score(y_test, y_pred_rf)
mse_rf = mean_squared_error(y_test, y_pred_rf)

print("Random Forest Regressor:")
print("R-squared:", r2_rf)
print("Mean Squared Error:", mse_rf)

# Calculate the accuracy using R-squared
accuracy_rf = r2_rf * 100

# Print the accuracy
print("Random Forest Regressor Accuracy:", accuracy_rf, "%")

# prompt: give  me the accuracy of the model

# Assuming you have already trained your model (e.g., Random Forest) and have y_test and y_pred
# ... (Your existing code for model training and prediction) ...

# Calculate accuracy for classification models (if applicable)
# If your model is a classification model, you can use accuracy_score:

# from sklearn.metrics import accuracy_score

# accuracy = accuracy_score(y_test, y_pred)
# print("Accuracy:", accuracy)

# For regression models, R-squared and MSE are typically used to evaluate performance.
# You can also calculate other metrics depending on the specific problem:

# Example:
print("Random Forest R-squared:", r2)  # r2 is already calculated
print("Random Forest Mean Squared Error:", mse)  # mse is already calculated

# If you want to focus on the accuracy of the model, R-squared is a good choice because it
# represents how well your model explains the variance in the target variable.
# However, if you want to focus on the error rate, then MSE is a good choice because it
# represents the average squared difference between your predicted values and actual values.

# prompt: do cross validation and give me accuracy in percentage

from sklearn.model_selection import cross_val_score

# Assuming you have already trained your Random Forest model:
# model = RandomForestRegressor(n_estimators=100, random_state=42)
# ... (Your existing code for model training) ...

# Perform cross-validation with 5 folds
cv_scores = cross_val_score(model, X_train_scaled, y_train, cv=5, scoring='r2')

# Calculate the mean R-squared score across the folds
mean_cv_r2 = cv_scores.mean()

# Convert R-squared to percentage
accuracy_percentage = mean_cv_r2 * 100

print(f"Cross-validation Mean R-squared: {mean_cv_r2:.4f}")
print(f"Accuracy (in percentage): {accuracy_percentage:.2f}%")

# prompt: dump the model of random forest on X_train and y_train

import pickle

# Assuming you have already trained your Random Forest model:
# model = RandomForestRegressor(n_estimators=100, random_state=42)
# ... (Your existing code for model training) ...

# Save the model to a file using pickle
filename = 'random_forest_model.pkl'
pickle.dump(model, open(filename, 'wb'))

print(f"Model saved to {filename}")

# Commented out IPython magic to ensure Python compatibility.
# # prompt: create an app.py file
# 
# %%writefile app.py
# import pickle
# import pandas as pd
# from flask import Flask, request, jsonify
# 
# app = Flask(__name__)
# 
# # Load the trained model
# with open('random_forest_model.pkl', 'rb') as f:
#     model = pickle.load(f)
# 
# @app.route('/predict', methods=['POST'])
# def predict():
#     try:
#         data = request.get_json()
#         # Assuming the input data is a dictionary with keys matching your model's input features
#         # You may need to adjust this based on your actual input data format
# 
#         # Preprocess the input data (if necessary) - e.g., label encoding, feature scaling
#         # ...
# 
#         # Make a prediction using your model
#         input_features = pd.DataFrame([data])  # Convert input to a DataFrame
#         prediction = model.predict(input_features)
# 
#         return jsonify({'prediction': prediction.tolist()})
# 
#     except Exception as e:
#         return jsonify({'error': str(e)}), 500
# 
# if __name__ == '__main__':
#     app.run(debug=True, host='0.0.0.0', port=5000)
#

# prompt: dump the app.py file

!cat app.py